System:
	System(set of tech/component)   ---serve-->  set of user  -----what----->  set of requirement
	ex(real-world): hospital, school,
	ex(computer system): instagram, netflix, whatsapp, youtube
building:
	- set of user
	- set of requirement
	- set of component

System-Design:
	process of
	- understanding set of user
	- understanding set of user's requirement
	- selecting core component and their interactions
	- pros and cons of system

Performance-metric:
	resource                bandwidth(100 each)    TimeTaken(sec)       throughput
		4                       4                     1                 400
		4                       2                     1                 200
		2                       4                     1                 200
		2                       2                     1                 200
		4                       4                     2                 200
        4                       2                     2                 100
        2                       4                     4                 500
        2                       2                     1                 200
	- throughput:
		tasks/time-unit ex: tps, speed(dis/time)
		number of API served per time-unit (tps), system-throughput ex: 100 tps
	- bandwidth(capacity):
		number of task one unit system/person able to perform ex: 1gbps bandwidth
	- latency(response time):
		time taken to process one request
	- consistency
	- availability
	- scalability


CAP-theorem: (	Consistency, Availability, Partition-tolerance)
	any two of the three can exist within a system
	Note: partition is something which happens due to network failure, so don't have control over it.
		we have to support partition tolerance in distributed system.
	CA:
	CP:
	AP:


process:
	- identify functional requirement
	- identify non-functional requirement

	functional requirement
		\  /
         \/ (outcome)
    component of the system
    (APIs, Communication, Events, message)


    	non-functional requirement
    		\  /
             \/ (outcome)
        tech choices
        Resource utilization(no. of resource)
        Data storage type (availability, consistency)
        scaling


        capacity-estimation(key- approximation):
            - no of user/transaction
            - amount of data
            - availability

metric:
    1 million = 10^6
    1 billion = 10^9
    1 trillion= 10^12

    1 million/day =  12/sec
    1 million/day =  700/min
    1 million/day =  4200/hour

    1 billion/day = 12000/sec

    round off to 10^ and 2^

don't mistake:
	- knowing functional and non-functional requirement
	- talking about the capacity estimation or scalability
	- discuss trade-off of choose resources(disadvantage)
	- discuss fault/error within the system like fault tolerance, scalability and their possible resolutions
	- better to say I don't know if you're not familiar with that tech-stack, expect follow-up solution
		better not to talk about which you don't know or say I have theoretical knowledge but not practical


scaling:
	vertical                                    horizontal
	single point failure                        resilient
	hardware limitation                         scale well
	NA                                          load balancing
	consistency                                 inconsistency(eventual consistent)
	fast (Inter-process comm)                   Slow(network-call/RPC)
	easy to debug error                         somewhere diff to track req


Aspects:
	vertical scaling
	preprocessing or cron jobs
	backup or replica(slave)
	horizontal scaling
	micro-service architecture(separation of concern)
	Distributed-system
	load-balancer
	Decoupled system (if their works are diff in nature)
	logging and metric
	Extensible (can extend same code for similar change)
	master-slave arch

K.I.S.S. : Keep It Simple stupid






